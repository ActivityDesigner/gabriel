#!/usr/bin/env python
#
# Cloudlet Infrastructure for Mobile Computing
#
#   Author: Kiryong Ha <krha@cmu.edu>
#
#   Copyright (C) 2011-2013 Carnegie Mellon University
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

import os
import sys
if os.path.isdir("../gabriel") == True:
    sys.path.insert(0, "..")

# from control VM
from gabriel.common.upnp_client import UPnPClient

import httplib
import urllib2
import time
import SocketServer
import socket
import select
import struct
import json
import Queue
import threading
import pprint
import multiprocessing
from urlparse import urlparse
from optparse import OptionParser


import gabriel
import gabriel.ucomm
LOG = gabriel.logging.getLogger()

upnp_client = UPnPClient()
output_queue = Queue.Queue()


class UCommError(Exception):
    pass


def process_command_line(argv):
    VERSION = 'gabriel ucomm server : %s' % gabriel.Const.VERSION
    DESCRIPTION = "Gabriel cognitive assistance"

    parser = OptionParser(usage='%prog [option]', version=VERSION,
            description=DESCRIPTION)

    parser.add_option(
            '-s', '--address', action='store', dest='address',
            help="(IP address:port number) of directory server")
    settings, args = parser.parse_args(argv)
    if len(args) >= 1:
        parser.error("invalid arguement")

    if hasattr(settings, 'address') and settings.address is not None:
        if settings.address.find(":") == -1:
            parser.error("Need address and port. Ex) 10.0.0.1:8081")
    return settings, args


def get_ip(iface = 'eth0'):
    import fcntl
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sockfd = sock.fileno()
    SIOCGIFADDR = 0x8915

    ifreq = struct.pack('16sH14s', iface, socket.AF_INET, '\x00' * 14)
    try:
        res = fcntl.ioctl(sockfd, SIOCGIFADDR, ifreq)
    except:
        return None
    ip = struct.unpack('16sH2x4s8x', res)[2]
    return socket.inet_ntoa(ip)


def put(url, json_string):
    end_point = urlparse("%s" % url)
    params = json.dumps(json_string)
    headers = {"Content-type": "application/json"}

    conn = httplib.HTTPConnection(end_point[1])
    conn.request("PUT", "%s" % end_point[2], params, headers)
    response = conn.getresponse()
    data = response.read()
    dd = json.loads(data)
    if dd.get("return", None) != "success":
        msg = "Cannot register UCOMM server\n%s", str(dd)
        raise UCommError(msg)
    print dd
    conn.close()


def register_ucomm(argv):
    settings, args = process_command_line(sys.argv[1:])
    service_list = None
    directory_url = None
    if settings.address is None:
        upnp_client.start()
        upnp_client.join()
        directory_url = "http://%s:%d/" % \
                    (upnp_client.http_ip_addr, upnp_client.http_port_number)
        service_list = upnp_client.service_list
    else:
        ip_addr, port = settings.address.split(":", 1)
        port = int(port)
        directory_url = "http://%s:%d/" % (ip_addr, port)
        meta_stream = urllib2.urlopen(directory_url)
        meta_raw = meta_stream.read()
        service_list = json.loads(meta_raw)
    pstr = pprint.pformat(service_list)
    json_info = {
        SERVICE_META.RESULT_RETURN_SERVER_LIST: "%s:%d" % (get_ip(), UCommConst.RESULT_RECEIVE_PORT),
        }
    put(directory_url, json_info)
    LOG.info("Gabriel Server :")
    LOG.info(pstr)
    return service_list


def main():
    global output_queue

    try:
        service_list = register_ucomm(sys.argv)
    except Exception as e:
        LOG.info(str(e))
        LOG.info("failed to register UCOMM to the control")
        sys.exit(1)
    control_vm_ip = service_list.get(SERVICE_META.UCOMM_COMMUNICATE_ADDRESS)
    control_vm_port = service_list.get(SERVICE_META.UCOMM_COMMUNICATE_PORT)

    # result pub/sub
    try:
        result_forward = None
        LOG.info("connecting to %s:%d" % (control_vm_ip, control_vm_port))
        result_forward = ResultForwardingClient((control_vm_ip, control_vm_port), \
                output_queue)
        result_forward.isDaemon = True
    except socket.error as e:
        # do not proceed if cannot connect to control VM
        LOG.info("Failed to connect to Control server (%s:%d)" % \
                (control_vm_ip, control_vm_port))
        if result_forward is not None:
            result_forward.terminate()
        return 2

    exit_status = 1
    ucomm_server = None
    ucomm_server = UCommServer(UCommConst.RESULT_RECEIVE_PORT, UCommServerHandler)
    ucomm_thread = threading.Thread(target=ucomm_server.serve_forever)
    ucomm_thread.daemon = True
    try:
        result_forward.start()
        ucomm_thread.start()
        while True:
            time.sleep(100)
    except Exception as e:
        sys.stderr.write(str(e))
        exit_status = 1
    except KeyboardInterrupt as e:
        sys.stdout.write("Exit by user\n")
        exit_status = 0
    finally:
        if ucomm_server is not None:
            ucomm_server.terminate()
        if result_forward is not None:
            result_forward.terminate()
    return exit_status


if __name__ == '__main__':
    ret = main()
    sys.exit(ret)
